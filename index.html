<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth Orbit Simulation (View from Moon - Textures)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">Earth orbiting Sun - View from the Moon (with Textures - Fallbacks Added)</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let sun, earth, moon, starField; // Make starField global for potential removal on error
        let earthOrbitRadius = 150;
        let moonOrbitRadius = 20;
        let earthOrbitSpeed = 0.001;
        let moonOrbitSpeed = 0.01;
        let earthRotationSpeed = 0.01;
        let clock = new THREE.Clock();
        let textureLoader;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            textureLoader = new THREE.TextureLoader();

            // --- IMPORTANT NOTE ON TEXTURE LOADING ---
            // Loading textures from external URLs (like below) might fail when
            // opening this HTML file directly from your local computer (file://...).
            // This is due to browser security restrictions (CORS).
            // If textures fail, the code below attempts to fall back to basic colors.
            // For reliable texture loading during development, serve this file
            // using a simple local web server.

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(earthOrbitRadius + moonOrbitRadius + 10, 20, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000); // Black background default
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 3000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // --- Create Celestial Bodies (with fallbacks) ---
            createSun();
            createEarth();
            createMoon();
            createStarfield();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- Create Sun (with Texture Fallback) ---
        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(20, 64, 64);
            // Default material (fallback)
            let sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            sun = new THREE.Mesh(sunGeometry, sunMaterial); // Create mesh with fallback material first
            scene.add(sun);

            const sunTextureUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/sun.jpg';
            console.log(`Attempting to load Sun texture from: ${sunTextureUrl}`);
            textureLoader.load(
                sunTextureUrl,
                 (texture) => { // Success callback
                    console.log("Sun texture loaded successfully.");
                    sun.material = new THREE.MeshBasicMaterial({ map: texture }); // Apply texture material
                    sun.material.needsUpdate = true;
                 },
                 undefined, // Progress callback
                 (err) => { // Error callback
                    console.error(`Error loading Sun texture from ${sunTextureUrl}. Using fallback color. Error: ${err.type || 'Unknown (check network/CORS)'}`);
                    // Fallback material is already set, no action needed here
                 }
            );
        }

        // --- Create Earth (with Texture Fallback) ---
        function createEarth() {
            const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
            // Default material (fallback) - Blue color
            let earthMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.8, metalness: 0.2 });
            earth = new THREE.Mesh(earthGeometry, earthMaterial); // Create mesh with fallback
            earth.position.x = earthOrbitRadius;
            scene.add(earth);

            const earthTextureUrl = 'https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg';
            console.log(`Attempting to load Earth texture from: ${earthTextureUrl}`);
            textureLoader.load(
                earthTextureUrl,
                 (texture) => { // Success
                    console.log("Earth texture loaded successfully.");
                    earth.material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 });
                    earth.material.needsUpdate = true;
                 },
                 undefined, // Progress
                 (err) => { // Error
                    console.error(`Error loading Earth texture from ${earthTextureUrl}. Using fallback color. Error: ${err.type || 'Unknown (check network/CORS)'}`);
                 }
            );
        }

        // --- Create Moon (with Texture Fallback) ---
        function createMoon() {
            const moonGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            // Default material (fallback) - Gray color
            let moonMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.95, metalness: 0.1 });
            moon = new THREE.Mesh(moonGeometry, moonMaterial); // Create mesh with fallback

            // Add moon only after earth is potentially created
            if (earth) {
                earth.add(moon);
            } else {
                console.error("Cannot add Moon, Earth object not ready.");
                return; // Stop if earth isn't there
            }

            const moonTextureUrl = 'https://threejs.org/examples/textures/planets/moon_1024.jpg';
             console.log(`Attempting to load Moon texture from: ${moonTextureUrl}`);
            textureLoader.load(
                moonTextureUrl,
                 (texture) => { // Success
                    console.log("Moon texture loaded successfully.");
                    moon.material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.95, metalness: 0.1 });
                    moon.material.needsUpdate = true;
                 },
                 undefined, // Progress
                 (err) => { // Error
                    console.error(`Error loading Moon texture from ${moonTextureUrl}. Using fallback color. Error: ${err.type || 'Unknown (check network/CORS)'}`);
                 }
            );
        }

        // --- Create Starfield (Logs Error on Failure) ---
        function createStarfield() {
            const starGeometry = new THREE.SphereGeometry(1500, 64, 64);
            // Basic material in case texture fails (though it won't be visible unless texture loads)
            let starMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }); // Black fallback
            starField = new THREE.Mesh(starGeometry, starMaterial); // Create mesh
            scene.add(starField);

            const starTextureUrl = 'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg';
            console.log(`Attempting to load Starfield texture from: ${starTextureUrl}`);
            textureLoader.load(
                starTextureUrl,
                 (texture) => { // Success
                     console.log("Starfield texture loaded successfully.");
                     texture.mapping = THREE.EquirectangularReflectionMapping;
                     starField.material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
                     starField.material.needsUpdate = true;
                 },
                 undefined, // Progress
                 (err) => { // Error
                     console.error(`Error loading Starfield texture from ${starTextureUrl}. Starfield may not be visible. Error: ${err.type || 'Unknown (check network/CORS)'}`);
                     // Optional: Remove the starfield mesh entirely on error
                     // if (starField) scene.remove(starField);
                 }
            );
        }

        // --- Handle Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Rotations and Orbits (with checks)
            if (earth) {
                earth.rotation.y += earthRotationSpeed;
                earth.position.x = Math.cos(elapsedTime * earthOrbitSpeed * 10) * earthOrbitRadius;
                earth.position.z = Math.sin(elapsedTime * earthOrbitSpeed * 10) * earthOrbitRadius;
            }
            if (moon) {
                moon.position.x = Math.cos(elapsedTime * moonOrbitSpeed * 10) * moonOrbitRadius;
                moon.position.z = Math.sin(elapsedTime * moonOrbitSpeed * 10) * moonOrbitRadius;
            }

            // Update Camera Position
            if (moon && earth) {
                const moonWorldPosition = new THREE.Vector3();
                moon.getWorldPosition(moonWorldPosition);
                const earthWorldPosition = new THREE.Vector3();
                earth.getWorldPosition(earthWorldPosition);

                const direction = new THREE.Vector3().subVectors(moonWorldPosition, earthWorldPosition).normalize();
                const cameraOffset = direction.multiplyScalar(5);
                camera.position.copy(moonWorldPosition).add(cameraOffset);
                camera.lookAt(earthWorldPosition);
            }

            renderer.render(scene, camera);
        }

        // --- Start ---
        window.onload = init;

    </script>
</body>
</html>
